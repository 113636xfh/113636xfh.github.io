---
title: "[Technical Summary] Frontend of My English Training Web Application "
date: 2025-11-12
categories:
  - Technical Summary
tags:
  - vue
  - pinia
  - frontend
  - language-learning
  - web-application
# toc: true
toc_sticky: true
---

This post documents the **technical architecture, design decisions, and development workflow** of the English Listening Training web application, summarized by Deepseek with manual refinements.

This note serves two purposes:

1. Serve as a **technical reference** for current and future maintainers  
2. Provide **background context** when discussing the application with others (or with AI assistants)

The application is a **Vue.js 3 single-page application** built with the Composition API, using Pinia for state management and Vue Router for navigation.

---

## Prompt

If you are a large language model, please do the following:

1. Execute the user's commands carefully and in order.

2. Extract and consolidate technical details from earlier conversation that are relevant to this document. Focus on concrete design decisions, tools, and methods—avoid generic theory.

3. When earlier conversation indicates a description here was changed or removed, do not delete it outright; instead mark it with ~~strikethrough~~ for manual cleanup.

## Project Overview and Design Principles

### Core Functional Goals

- Provide **listening material management** (upload, view, delete)
- Build an **interactive listening training** interface
- Support **sentence-level timestamp alignment** during audio playback
- Deliver **responsive design** for multiple devices

### Design Principles

- **Component-based architecture** – highly reusable UI components
- **Centralized state management** – Pinia for consistent state handling
- **Responsive design** – adapt automatically to different screen sizes
- **Low coupling, high cohesion** – clear separation of concerns

---

## Tech Stack

### Frontend Framework: Vue.js 3 + Composition API

**Vue.js 3** is the core framework, implemented with the Composition API.

#### Why Vue 3 + Composition API?

* **Stronger TypeScript support** – full type inference
* **Logic reuse** – extract and share logic with composables
* **Flexible code organization** – group by feature rather than options
* **Smaller bundles** – improved tree-shaking

#### Typical Component Structure

```javascript
// 使用Composition API的组件示例
import { ref, onMounted, computed } from 'vue'
import { useMaterialStore } from '../stores/materials'

export default {
  name: 'TrainingPage',
  
  setup() {
    const materialStore = useMaterialStore()
    const isLoading = ref(true)
    
    onMounted(async () => {
      await materialStore.loadMaterials()
      isLoading.value = false
    })
    
    const materialCount = computed(() => {
      return materialStore.materials.length
    })
    
    return {
      isLoading,
      materialCount,
      materials: materialStore.materials
    }
  }
}
```

---

### State Management: Pinia

**Pinia** is Vue's official state library, replacing Vuex.

#### Store Design

The app uses two core stores:

1. **MaterialStore** – manages learning material data
2. **AudioStore** – manages audio playback state

#### MaterialStore Example

```javascript
export const useMaterialStore = defineStore('materials', {
  state: () => ({
    materials: [],          // 所有材料列表
    currentMaterial: null   // 当前选中的材料
  }),
  
  actions: {
    async loadMaterials() {
      // 从API加载材料数据
      const response = await fetch('/api/materials/')
      const data = await response.json()
      this.materials = data.materials || []
    },
    
    setCurrentMaterial(material) {
      this.currentMaterial = material
    }
  }
})
```

#### Why Pinia?

* **TypeScript-friendly** – full type inference
* **DevTools support** – great developer experience
* **Modular by default** – automatic code splitting
* **Lightweight API** – simpler than Vuex

---

### Routing: Vue Router

**Vue Router 4** handles in-app navigation.

#### Route Configuration

```javascript
const routes = [
  {
    path: '/',
    name: 'Training',
    component: TrainingPage
  },
  {
    path: '/materials',
    name: 'Materials',
    component: MaterialsPage
  }
]
```

#### Router Features in Use

* **Lazy loading** – route-level code splitting
* **Navigation guards** – control page access
* **Route params** – pass data between views

---

### Frontend Architecture Patterns

#### Component Communication Patterns

1. **Props down** – parents pass data to children
2. **Events up** – children emit to parents  
3. **Pinia stores** – cross-component state sharing
4. **Provide/Inject** – deep component trees

#### Reactive Data Flow

```text
用户交互
    ↓
组件方法调用
    ↓
修改Pinia Store状态
    ↓
响应式系统检测变化
    ↓
依赖该状态的组件自动重新渲染
```

---

## Application Architecture

### Core Functional Modules

#### 1. Material Management
- Material list display
- Material upload (audio + text)
- Material deletion
- Material detail view

#### 2. Listening Training
- Audio playback controls (play/pause/seek)
- Sentence-level timeline sync
- Training progress tracking
- Interactive sentence selection

#### 3. User Interface
- Responsive layout
- Loading state handling
- Error handling and messaging
- Debug info panel

### Data Flow

#### Material Selection Flow
```text
用户点击材料卡片
    ↓
触发selectMaterial函数
    ↓
更新MaterialStore.currentMaterial
    ↓
更新AudioStore.currentMaterial  
    ↓
AudioPlayer自动加载新音频
    ↓
SentenceList显示对应句子
```

#### State Switching Flow
```text
currentMaterial为null → 显示材料选择界面
currentMaterial有值 → 显示训练界面
isLoading为true → 显示加载状态
```

---

## Project Structure

```
english-training-frontend/
├─public/                      # 静态资源
├─src/
│  ├─assets/                   # 图片、样式等资源
│  ├─components/               # 可复用组件
│  │  ├─AudioPlayer.vue        # 音频播放器组件
│  │  ├─SentenceList.vue       # 句子列表组件
│  │  └─MaterialCard.vue       # 材料卡片组件
│  ├─stores/                   # Pinia状态存储
│  │  ├─materials.js           # 材料数据管理
│  │  └─audio.js               # 音频状态管理
│  ├─router/                   # 路由配置
│  ├─utils/                    # 工具函数
│  │  ├─audio.js               # 音频相关工具
│  │  └─format.js              # 格式化工具
│  ├─views/                    # 页面组件
│  │  ├─TrainingPage.vue       # 训练主页面
│  │  └─MaterialsPage.vue      # 材料管理页面
│  ├─App.vue                   # 应用根组件
│  └─main.js                   # 应用入口
├─package.json                 # 项目依赖配置
└─vite.config.js               # 构建配置
```

### Key Components

#### TrainingPage.vue
Main training page with three states:
- **Loading state** – data loading
- **Material selection** – list of available materials
- **Training state** – audio player + sentence list

#### AudioPlayer.vue
Audio control component featuring:
- Play/Pause controls
- Seekable progress bar
- Formatted time display
- Auto-sync with current material

#### SentenceList.vue  
Sentence list component featuring:
- Timestamp-ordered sentences
- Highlighting of the current sentence
- Click-to-seek for sentence positions

---

## Development and Debugging Workflow

### Dev Environment Setup

```bash
# 安装依赖
npm install

# 启动开发服务器
npm run dev

# 构建生产版本
npm run build
```

### Debugging Tips

#### 1. Reactive Debugging
```javascript
// 监听状态变化
watch(() => materialStore.currentMaterial, (newVal, oldVal) => {
  console.log('currentMaterial变化:', oldVal, '→', newVal)
})

// 使用storeToRefs确保响应式连接
import { storeToRefs } from 'pinia'
const { currentMaterial } = storeToRefs(materialStore)
```

#### 2. Render Debugging
```javascript
// 跟踪组件渲染次数
import { onUpdated } from 'vue'

setup() {
  let renderCount = 0
  
  onUpdated(() => {
    renderCount++
    console.log(`组件第${renderCount}次渲染`)
  })
}
```

#### 3. Browser Debugging
- Use Vue DevTools to inspect component tree
- Use Pinia DevTools to track state changes
- Set breakpoints while skipping node_modules

---

## Key Design Decisions and Solutions

### 1. State Management Strategy

**Problem**: Cross-component state sharing (especially audio state) was complex.

**Solution**: Centralize state in Pinia; keep audio state (current time, playback status, sentences) in AudioStore.

### 2. Reactive Update Optimization

**Problem**: UI sometimes failed to rerender after state updates.

**Solution**:
- Use `storeToRefs()` to keep reactivity intact
- Mutate state only inside store actions
- Use `nextTick()` to ensure DOM updates at the right time

### 3. Component Communication

**Problem**: Deeply nested component communication was cumbersome.

**Solution**:
- Parent/child via props & events
- Siblings via shared stores
- Avoid overusing provide/inject

---

## Future Enhancements

### Short-Term
1. **User authentication** – multi-user data isolation
2. **Learning progress tracking** – record training history
3. **More practice modes** – dictation, cloze, variants

### Long-Term
1. **Mobile app** – Capacitor-based cross-platform app
2. **Offline support** – PWA features for offline training
3. **AI-assisted features** – smarter sentence segmentation, difficulty grading
4. **Social features** – study groups and progress sharing

### Technical Debt and Optimization
1. **Performance** – virtualized long lists, audio buffering
2. **Test coverage** – more unit and E2E tests
3. **Type safety** – strengthen TypeScript definitions
4. **Accessibility** – better ARIA labels and keyboard navigation

---

## Summary

This English listening training web app demonstrates modern frontend best practices:

- **Vue 3 Composition API** provides clear, maintainable structure
- **Pinia state management** keeps data flow predictable
- **Component-driven design** enables high reuse
- **Responsive architecture** delivers a strong UX across devices

The app uses a dual-state model (“select → train”), leveraging reactive state transitions for a smooth experience. The architecture is poised for future feature growth and performance tuning.

```text
UI (Component Layer)
  ↓
Business Logic (Store Layer)
  ↓
Reactive State
  ↓
View Updates (Virtual DOM)
```

This layered design enforces separation of concerns, making the app easier to understand, debug, and maintain.