---
title: "[Technical Summary] Backend of My English Training Web Application "
date: 2025-11-27
categories:
  - Technical Summary
tags:
  - fastapi
  - sqlite
  - python
  - backend
  - language-learning
  - web-application
toc_sticky: true
---

This post documents the **technical architecture, design decisions, and development workflow** of the English Listening Training web application backend, summarized by Deepseek with manual refinements.

This note serves two purposes:

1. Serve as a **technical reference** for current and future maintainers  
2. Provide **background context** when discussing the application with others (or with AI assistants)

The backend is a **FastAPI-based RESTful API service** built with Python, using SQLite as the database and integrating audio processing capabilities.

---

## Prompt

If you are a large language model, please do the following:

1. Execute the user's commands carefully and in order.

2. Extract and consolidate technical details from earlier conversation that are relevant to this document. Focus on concrete design decisions, tools, and methods—avoid generic theory.

3. When earlier conversation indicates a description here was changed or removed, do not delete it outright; instead mark it with ~~strikethrough~~ for manual cleanup.

## Project Overview and Design Principles

### Core Functional Goals

- Provide **listening material management** APIs (upload, view, delete)
- Implement **audio processing** (duration extraction, auto-segmentation, format conversion)
- Support **sentence-level timestamps** storage and adjustment
- Provide a **vocabulary management system** and **intelligent training plan** generation
- Enable **offline-first data sync**

### Design Principles

- **Layered architecture** – clear separation of concerns (API, service, data)
- **RESTful API design** – standards-compliant endpoints
- **Dependency injection** – use FastAPI `Depends` for component wiring
- **Exception handling** – unified error responses and logging
- **Configuration-first** – environment-aware configuration management

---

## Tech Stack

### Backend Framework: FastAPI + Python 3.9

**FastAPI** is the core backend framework, built on Python 3.9+ with strong typing and async support.

#### Why FastAPI?

* **High performance** – Starlette + Pydantic; performance close to Node.js/Go
* **Developer efficiency** – auto-generated interactive docs (Swagger UI, ReDoc)
* **Type safety** – rich Python type hints reduce runtime errors
* **Async-first** – native async/await for I/O-heavy workloads
* **Dependency injection** – flexible, powerful `Depends` system

#### Typical API Endpoint

```python
# 使用FastAPI的异步端点和依赖注入
@router.post("/materials/")
async def import_material(
    title: str = Form(...),
    audio_file: UploadFile = File(...),
    text_file: UploadFile = File(...),
    description: Optional[str] = Form(None),
    db: Session = Depends(get_db)
):
    """
    导入新材料 - 处理音频文件上传、文本解析和时间分割
    """
    try:
        # 验证文件格式和大小
        validate_files(audio_file, text_file)
        
        # 保存上传的文件
        audio_path = await save_uploaded_file(audio_file)
        
        # 处理业务逻辑
        result = await material_service.import_material(
            db=db,
            title=title,
            audio_path=audio_path,
            text_content=await read_text_file(text_file),
            description=description
        )
        
        return result
        
    except ValidationError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        logger.error(f"导入材料失败: {str(e)}")
        raise HTTPException(status_code=500, detail="服务器内部错误")
```

---

### Database: SQLite + SQLAlchemy ORM

**SQLite** serves as the lightweight relational DB; **SQLAlchemy 2.0** as the ORM.

#### Why SQLite + SQLAlchemy?

* **Zero-config deployment** – single-file DB, no separate service
* **Dev-friendly** – great for rapid prototyping/testing
* **ORM abstraction** – powerful mapping and query construction
* **Clear migration path** – easy move to PostgreSQL/MySQL for production
* **Transactions** – full ACID guarantees

#### Core Data Models

```python
# 分层的数据模型设计
class Material(Base):
    """学习材料核心模型"""
    __tablename__ = "materials"
    
    id = Column(String(36), primary_key=True, default=generate_uuid)
    title = Column(String(255), nullable=False)
    audio_file_path = Column(String(500), nullable=False)
    text_content = Column(Text, nullable=False)
    duration = Column(Float, default=0.0)
    word_count = Column(Integer, default=0)
    difficulty_level = Column(String(50), default="medium")
    created_at = Column(DateTime(timezone=True), server_default=func.now())

class SentenceSegment(Base):
    """句子时间分段模型"""
    __tablename__ = "sentence_segments"
    
    id = Column(String(36), primary_key=True, default=generate_uuid)
    material_id = Column(String(36), ForeignKey("materials.id"), nullable=False)
    sentence_text = Column(Text, nullable=False)
    start_time = Column(Float, nullable=False)  # 开始时间(秒)
    end_time = Column(Float, nullable=False)    # 结束时间(秒)
    order_index = Column(Integer, nullable=False)
    adjusted_times = Column(JSON, default=[])   # 时间调整记录
```

#### DB Session Management

```python
# 使用依赖注入管理数据库会话生命周期
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# 在API端点中使用
@router.get("/materials/{material_id}")
async def get_material(
    material_id: str,
    db: Session = Depends(get_db)
):
    material = material_crud.get_material(db, material_id)
    if not material:
        raise HTTPException(status_code=404, detail="材料不存在")
    return material
```

---

### Audio Processing: pydub + FFmpeg

**pydub** handles audio processing; **FFmpeg** powers low-level operations.

#### Audio Capabilities

- **Duration extraction** – accurate audio length
- **Format conversion** – MP3/WAV/M4A/OGG interchange
- **Precise segmentation** – millisecond-level slicing
- **Loudness normalization** – consistent volume
- **Silence detection** – identify silent sections

#### Audio Service Design

```python
class AudioProcessingService:
    """音频处理服务 - 封装所有音频相关操作"""
    
    def __init__(self):
        self.supported_formats = ['.mp3', '.wav', '.m4a', '.ogg']
    
    async def auto_segment_audio(self, audio_path: str, text_content: str) -> dict:
        """
        自动分割音频与文本对齐
        简化版本：基于句子数量平均分配时间
        生产环境：可集成语音识别进行精确对齐
        """
        duration = self.get_audio_duration(audio_path)
        sentences = text_utils.split_into_sentences(text_content)
        
        segments = []
        for i, sentence in enumerate(sentences):
            # 计算时间分段（简化算法）
            start_time = (i / len(sentences)) * duration
            end_time = ((i + 1) / len(sentences)) * duration
            
            segments.append({
                "sentence_text": sentence,
                "start_time": round(start_time, 2),
                "end_time": round(end_time, 2),
                "order_index": i
            })
        
        return {
            "segments": segments,
            "duration": duration,
            "word_count": text_utils.count_words(text_content)
        }
```


## Backend Architecture Patterns

### Layered Architecture

#### 1. API Layer (Endpoints)
- Handle HTTP requests/responses
- Input validation and serialization
- Error handling and status codes

#### 2. Service Layer
- Core business rules
- Coordinate multi-entity operations
- Exception handling

#### 3. Data Access Layer (CRUD)
- Encapsulate DB operations
- Provide unified data interfaces
- Handle data mapping/conversion

#### 4. Data Model Layer
- Define DB schemas
- Establish relationships
- Provide ORM mappings

### Dependency Injection Pattern

FastAPI `Depends` manages component wiring, improving testability and maintainability.

```python
# 依赖项定义
async def get_current_user(token: str = Depends(oauth2_scheme)):
    """获取当前用户（预留认证功能）"""
    # 解析token，返回用户信息
    return {"user_id": "default_user"}

# 在端点中使用依赖项
@router.get("/user/profile")
async def get_user_profile(
    current_user: dict = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """获取用户个人资料"""
    # 使用注入的当前用户和数据库会话
    return {"user_id": current_user["user_id"]}
```

---

## Application Architecture

### Core Functional Modules

#### 1. Material Management
- **Import** – upload audio + text, auto time-splitting
- **Query** – list, detail, search/filter
- **Update** – edit metadata, adjust sentence timestamps
- **Delete** – cascade removal of related data

#### 2. Audio Processing
- **Basics** – duration, format conversion, loudness normalization
- **Advanced** – auto segmentation, silence detection, playback speed
- **Segment management** – extract/merge audio clips

#### 3. Vocabulary Management
- **Extraction** – auto-extract words from materials
- **Proficiency tracking** – update vocab mastery from training
- **Categorization** – auto bucket into new/known words
- **Lookup** – find sentences by word

#### 4. Training Plan
- **Smart generation** – personalized plans from user weaknesses
- **Progress tracking** – record sessions and completion
- **Effect analysis** – stats and visualization

#### 5. Data Sync
- **Offline support** – local storage and change logs
- **Smart sync** – incremental sync when online
- **Conflict resolution** – handle multi-device conflicts

### Data Flow

#### Material Import Flow
```text
接收上传的音频和文本文件
    ↓
验证文件格式和大小
    ↓
保存文件到指定位置
    ↓
解析文本内容，分割句子
    ↓
分析音频，获取时长和分段信息
    ↓
创建材料记录和句子分段记录
    ↓
提取文本中的单词，更新词汇表
    ↓
返回导入结果和材料ID
```

#### Training Plan Generation Flow
```text
分析用户的历史训练数据
    ↓
识别薄弱词汇和句子
    ↓
查找包含薄弱词汇的相关句子
    ↓
根据熟练度排序训练内容
    ↓
生成个性化训练序列
    ↓
创建训练计划记录
    ↓
返回训练计划详情
```

---

## Project Structure

```
english-training-backend/
├─app/
│  ├─__init__.py
│  ├─main.py                      # FastAPI应用入口，路由注册，中间件配置
│  ├─config.py                    # 应用配置管理（数据库、文件路径等）
│  ├─database/
│  │  ├─__init__.py
│  │  ├─database.py               # 数据库连接配置和会话管理
│  │  └─models.py                 # SQLAlchemy数据模型定义
│  ├─api/
│  │  ├─__init__.py
│  │  ├─dependencies.py           # 依赖项定义（数据库、认证等）
│  │  └─endpoints/                # API端点路由
│  │      ├─materials.py          # 材料管理端点
│  │      ├─audio.py              # 音频处理端点
│  │      ├─vocabulary.py         # 词汇管理端点
│  │      └─training.py           # 训练管理端点
│  ├─services/                    # 业务逻辑服务层
│  │  ├─material_service.py       # 材料业务逻辑
│  │  ├─audio_service.py          # 音频业务逻辑
│  │  ├─vocabulary_service.py     # 词汇业务逻辑
│  │  ├─training_service.py       # 训练业务逻辑
│  │  └─sync_service.py           # 数据同步逻辑
│  ├─schemas/                     # Pydantic数据验证模型
│  │  ├─material_schemas.py       # 材料相关Schema
│  │  ├─audio_schemas.py          # 音频相关Schema
│  │  ├─vocabulary_schemas.py     # 词汇相关Schema
│  │  └─training_schemas.py       # 训练相关Schema
│  ├─crud/                        # 数据访问层（CRUD操作）
│  │  ├─material_crud.py          # 材料CRUD操作
│  │  ├─sentence_crud.py          # 句子分段CRUD操作
│  │  ├─vocabulary_crud.py        # 词汇CRUD操作
│  │  └─training_crud.py          # 训练CRUD操作
│  └─utils/                       # 工具函数库
│      ├─audio_utils.py           # 音频处理工具
│      ├─file_utils.py            # 文件操作工具
│      ├─text_utils.py            # 文本处理工具
│      └─time_utils.py            # 时间处理工具
├─static/                         # 静态文件目录
│  ├─audio/                       # 音频文件存储
│  └─uploads/                     # 上传文件临时存储
├─requirements.txt                # Python依赖包清单
├─run.py                          # 应用启动脚本
└─README.md                       # 项目说明文档
```

### Key Module Notes

#### main.py — Application entry
Creates/configures FastAPI app:
- Middleware (CORS, logging, etc.)
- Route registration and grouping
- Exception handlers
- Static file mounting

#### material_service.py — Material service
Core logic for import/processing:
- File upload and validation
- Text parsing and sentence splitting
- Audio analysis and alignment
- DB transaction management

#### audio_service.py — Audio service
Audio processing wrapper:
- Cross-platform audio operations
- Error handling and retries
- Performance optimizations and caching

---

## Development and Debugging Workflow

### Dev Environment Setup

```bash
# 1. 创建虚拟环境
python -m venv venv

# 2. 激活虚拟环境
# Linux/Mac:
source venv/bin/activate
# Windows:
venv\Scripts\activate

# 3. 安装依赖
pip install -r requirements.txt

# 4. 创建必要目录
mkdir -p static/audio static/audio/segments uploads

# 5. 启动开发服务器
uvicorn app.main:app --reload --host 0.0.0.0 --port 8000
```

### API Documentation

FastAPI auto-generates full API docs:
- **Swagger UI**: http://localhost:8000/docs
- **ReDoc**: http://localhost:8000/redoc

### Debugging Tips

#### 1. Structured Logging
```python
import logging

logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Log key operations
logger.info(f"Start importing material: {title}")
logger.debug(f"Audio file size: {file_size} bytes")
logger.error(f"Audio processing failed: {str(e)}", exc_info=True)
```

#### 2. DB Debugging
```python
# 启用SQLAlchemy查询日志
import logging
logging.getLogger('sqlalchemy.engine').setLevel(logging.INFO)

# Inspect generated SQL
from sqlalchemy import text
query = db.query(Material).filter(Material.difficulty == "easy")
print(str(query.statement.compile(dialect=db.bind.dialect)))
```

#### 3. Debug Endpoints
```python
@router.get("/debug/database-info")
async def debug_database_info(db: Session = Depends(get_db)):
    """Debug endpoint: inspect DB tables"""
    tables = db.execute(text("SELECT name FROM sqlite_master WHERE type='table';"))
    return {"tables": [row[0] for row in tables]}
```

#### 4. Performance Profiling
```python
# Measure execution time
import time

def timed_operation():
    start_time = time.time()
    # 执行操作
    elapsed = time.time() - start_time
    logger.info(f"操作耗时: {elapsed:.2f}秒")
```

## 部署架构

### 开发环境部署
```bash
# Standalone dev deployment
uvicorn app.main:app --reload --host 0.0.0.0 --port 8000
```

### 生产环境部署
```yaml
# Docker Compose multi-service deployment
version: '3.8'
services:
  backend:
    build: .
    ports:
      - "8000:8000"
    volumes:
      - ./data:/app/data
      - ./static:/app/static
    environment:
      - DATABASE_URL=postgresql://user:password@db:5432/english_training
      - DEBUG=False
  
  db:
    image: postgres:14
    environment:
      - POSTGRES_DB=english_training
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
    volumes:
      - postgres_data:/var/lib/postgresql/data
  
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./static:/usr/share/nginx/html/static

volumes:
  postgres_data:
```

### Monitoring and Ops
- **Health check**: `GET /health`
- **Metrics**: `GET /metrics` (Prometheus-ready)
- **Log collection**: structured logs for ELK
- **Error tracking**: Sentry hook

---

## Future Enhancements

### Short-Term (1–3 months)
1. **User system** – multi-user support; per-user data isolation
2. **Smarter audio segmentation** – ASR-assisted alignment
3. **ECDICT integration** – local English dictionary data
4. **Training algorithm tuning** – spaced-repetition style review


---

## Summary

This backend showcases modern Python best practices:

- **FastAPI** for high-performance, type-safe APIs
- **Layered architecture** for maintainability and extensibility  
- **Async model** to leverage Python concurrency
- **SQLAlchemy ORM** for flexible data access
- **Robust error handling** for stability

The modular, layered design keeps responsibilities clear and collaboration smooth, while leaving room for future features like richer user systems, smarter recommendations, and multi-device sync.

```text
HTTP Request → API Endpoint → Services → Data Access → Database
             ↓             ↓            ↓            ↓            ↓
    Response ← Exception Handling ← Business Logic ← Data Ops ← Persistence
```

This clear data flow and separation of concerns make the system easier to understand, test, and maintain, while staying flexible for future evolution from single-user to multi-user scenarios.